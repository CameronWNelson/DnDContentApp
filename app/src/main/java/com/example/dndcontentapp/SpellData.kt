package com.example.dndcontentapp

import android.database.Cursor
import android.os.Parcel
import android.os.Parcelable
import java.util.Locale

enum class School {ABJURATION, CONJURATION, DIVINATION, ENCHANTMENT, EVOCATION, ILLUSION, NECROMANCY, TRANSMUTATION, ERROR }
enum class PlayerClass {ARTIFICER, BARD, CLERIC, DRUID, PALADIN, RANGER, SORCERER, WARLOCK, WIZARD, ERROR}
enum class Subclass {LORE, LAND, LIFE, FIEND, DEVOTION, ERROR}
class SpellData (val name: String, val level: Int, val school: School, val ritual: Boolean, val concentration: Boolean, val verbal: Boolean, val somatic: Boolean, val material: Boolean, val materialText: String, val range: String, val duration: String, val castTime: String, val spellText: String, val playerClass: ArrayList<PlayerClass>, val subclass: ArrayList<Subclass>) : Parcelable {
    constructor(parcel: Parcel) : this(
        parcel.readString()!!,
        parcel.readInt(),
        School.values()[parcel.readInt()],
        ExtraUtilities.intToBool(parcel.readInt()),
        ExtraUtilities.intToBool(parcel.readInt()),
        ExtraUtilities.intToBool(parcel.readInt()),
        ExtraUtilities.intToBool(parcel.readInt()),
        ExtraUtilities.intToBool(parcel.readInt()),
        parcel.readString()!!,
        parcel.readString()!!,
        parcel.readString()!!,
        parcel.readString()!!,
        parcel.readString()!!,
        ArrayList<PlayerClass>(),
        ArrayList<Subclass>()
    ) {
        // convert from ints back into enums
        val parcelPC = ArrayList<Int>()
        parcel.readList(parcelPC, Int::class.java.classLoader)
        for (item in parcelPC) {
            playerClass.add(PlayerClass.values()[item])
        }
        val parcelSC = ArrayList<Int>()
        parcel.readList(parcelSC, Int::class.java.classLoader)
        for (item in parcelSC)
            subclass.add(Subclass.values()[item])
    }

    override fun describeContents(): Int {
        return 0
    }
    override fun writeToParcel(dest: Parcel, flags: Int) {
        dest.writeString(name)
        dest.writeInt(level)
        dest.writeInt(school.ordinal)

        // necessary to convert for older api versions
        dest.writeInt(ExtraUtilities.boolToInt(ritual))
        dest.writeInt(ExtraUtilities.boolToInt(concentration))
        dest.writeInt(ExtraUtilities.boolToInt(verbal))
        dest.writeInt(ExtraUtilities.boolToInt(somatic))
        dest.writeInt(ExtraUtilities.boolToInt(material))
        dest.writeString(materialText)

        dest.writeString(range)
        dest.writeString(duration)
        dest.writeString(castTime)
        dest.writeString(spellText)

        // convert enums to ints for parcels
        val pc = ArrayList<Int>()
        for (i in playerClass)
            pc.add(i.ordinal)
        dest.writeList(pc)
        val sc = ArrayList<Int>()
        for (i in subclass)
            sc.add(i.ordinal)
        dest.writeList(sc)
    }

    // returns the level and school, formatted for display
    fun levelAndSchoolToString(): String {
        if (level == 0) return "${schoolToString(true)} ${levelToString()}"
        return "${levelToString()} ${schoolToString(false)}"
    }

    // returns the level of the spell with a suffix
    private fun levelToString(): String {
        return when (this.level) {
            0 -> "cantrip"
            1 -> "1st level"
            2 -> "2nd level"
            3 -> "3rd level"
            4 -> "4th level"
            5 -> "5th level"
            6 -> "6th level"
            7 -> "7th level"
            8 -> "8th level"
            9 -> "9th level"
            else -> "error"
        }
    }

    // returns the text form of the school enum, can be capitalized
    private fun schoolToString (capital: Boolean): String {
        var returnVal = this.school.name.lowercase()
        if (capital) {
            // auto-generated by IDE to replace String.Capitalize()
            return returnVal.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.ROOT) else it.toString() }
        }
        return returnVal
    }

    // returns the text form of the components
    fun componentToString (): String {
        var text: String = ""
        if (verbal) text += "V"
        if (somatic) {
            if (!text.contentEquals("")) text += ", "
            text += "S"
        }
        if (material) {
            if (!text.contentEquals("")) text += ", "
            text += "M ($materialText)"
        }
        return text
    }

    // public methods to build new instances of SpellData using Parcels or Cursors
    companion object CREATOR : Parcelable.Creator<SpellData> {
        override fun createFromParcel(parcel: Parcel): SpellData {
            return SpellData(parcel)
        }

        override fun newArray(size: Int): Array<SpellData?> {
            return arrayOfNulls(size)
        }

        // Parse a database entry using cursor data
        fun createFromCursor (cursor: Cursor): SpellData {
            val name = cursor.getString(cursor.run { getColumnIndex("name") })
            val level = cursor.getInt(cursor.run { getColumnIndex("level") })
            val schoolString = cursor.getString(cursor.run { getColumnIndex("school") })
            var school = School.ERROR
            for (s in School.values()) {
                if (schoolString.compareTo(s.toString(), true) == 0) {
                    school = s
                    break
                }
            }
            val ritual = ExtraUtilities.intToBool(cursor.getInt(cursor.run { getColumnIndex("ritual") }))
            val concentration = ExtraUtilities.intToBool(cursor.getInt(cursor.run { getColumnIndex("concentration") }))
            val verbal = ExtraUtilities.intToBool(cursor.getInt(cursor.run { getColumnIndex("verbal") }))
            val somatic = ExtraUtilities.intToBool(cursor.getInt(cursor.run { getColumnIndex("somatic") }))
            val material = ExtraUtilities.intToBool(cursor.getInt(cursor.run { getColumnIndex("material") }))
            val materialText = cursor.getString(cursor.run { getColumnIndex("materialText") })
            val range = cursor.getString(cursor.run { getColumnIndex("range") })
            val duration = cursor.getString(cursor.run { getColumnIndex("duration") })
            val castTime = cursor.getString(cursor.run { getColumnIndex("castTime") })
            val spellText = cursor.getString(cursor.run { getColumnIndex("spellText") })
            var playerClass = ArrayList<PlayerClass>()
            val classesString = cursor.getString(cursor.run { getColumnIndex("classes") })
            for (pc in PlayerClass.values()) {
                if (classesString.contains(pc.toString(), true))
                    playerClass.add(pc)
            }
            var subclass = ArrayList<Subclass>()
            val subclassString = cursor.getString(cursor.run { getColumnIndex("subclasses") })
            for (s in Subclass.values()) {
                if (subclassString.contains(s.toString(), true))
                    subclass.add(s)
            }
            return SpellData(name, level, school, ritual, concentration, verbal, somatic, material, materialText, range, duration, castTime, spellText, playerClass, subclass)
        }
    }
}